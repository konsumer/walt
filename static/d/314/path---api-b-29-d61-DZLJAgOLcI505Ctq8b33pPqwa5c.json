{"data":{"allDocumentationJs":{"edges":[{"node":{"name":"def","kind":"constant","returns":[],"params":[],"description":{"childMarkdownRemark":{"html":"<p>Ported from <a href=\"https://github.com/WebAssembly/wabt/blob/master/src/opcode.def\">opcode.def</a></p>"}}}},{"node":{"name":"opcode","kind":"constant","returns":[],"params":[{"name":"result","type":{"name":null}},{"name":"first","type":{"name":null}},{"name":"second","type":{"name":null}},{"name":"size","type":{"name":"number"}},{"name":"code","type":{"name":"number"}},{"name":"name","type":{"name":"string"}},{"name":"text","type":{"name":"string"}}],"description":{"childMarkdownRemark":{"html":"<p>Convert Opcode definiton to usable object(s)\n*</p>"}}}},{"node":{"name":"opcodeFromOperator","kind":"constant","returns":[{"type":{"type":"NameExpression","name":"RawOpcodeType"}}],"params":[{"name":"$0","type":{"name":null}}],"description":{"childMarkdownRemark":{"html":"<p>Return opcode mapping to the operator. Signed result is always preferred</p>"}}}},{"node":{"name":"test","kind":null,"returns":[],"params":[],"description":{"childMarkdownRemark":{"html":"<p>Test JavaScript <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators\">arithmetic operators</a></p>"}}}},{"node":{"name":"curry","kind":null,"returns":[],"params":[],"description":{"childMarkdownRemark":{"html":"<p>Syntax Analysis</p>\n<p>The parser below creates the \"bare\" Abstract Syntax Tree.</p>"}}}},{"node":{"name":"generateBinaryExpression","kind":"constant","returns":[],"params":[{"name":"node","type":null},{"name":"parent","type":null}],"description":{"childMarkdownRemark":{"html":"<p>Transform a binary expression node into a list of opcodes</p>"}}}},{"node":{"name":"invariant","kind":null,"returns":[],"params":[],"description":{"childMarkdownRemark":{"html":"<p>Syntax Analysis</p>\n<p>The parser below creates the \"bare\" Abstract Syntax Tree.</p>"}}}},{"node":{"name":"makeLexer","kind":"function","returns":[],"params":[],"description":{"childMarkdownRemark":{"html":"<p>Returns a custom lexer. This wrapper API is necessary to ignore comments\nin all of the subsequent compiler phases, unfortunately.</p>\n<p>TODO: Maybe consider adding comment nodes back to the AST. IIRC this causes\nlots of ambiguous grammar for whatever reason.</p>"}}}},{"node":{"name":"invariant","kind":null,"returns":[],"params":[],"description":{"childMarkdownRemark":{"html":"<p>Generate an Intermediate version for a WebAssembly function type\n*</p>"}}}},{"node":{"name":"invariant","kind":null,"returns":[],"params":[],"description":{"childMarkdownRemark":{"html":"<div>Sizeof helper plugin. Maps size(<THING>) to a static i32 constant</div>"}}}},{"node":{"name":"fsearch","kind":"constant","returns":[],"params":[{"name":"node","type":null}],"description":{"childMarkdownRemark":{"html":"<p>A very basic trie with functional,recursive search</p>"}}}},{"node":{"name":"semantics","kind":"function","returns":[{"type":{"type":"NameExpression","name":"NodeType"}}],"params":[{"name":"ast","type":{"name":"NodeType"}},{"name":"extraSemantics","type":{"name":null}},{"name":"options","type":{"name":"SemanticOptions"}}],"description":{"childMarkdownRemark":{"html":"<p>Return AST with full transformations applied</p>"}}}}]}},"pageContext":{}}