{"data":{"markdownRemark":{"html":"<h2>Basic Types</h2>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Syntax</th>\n<th align=\"center\">s-expression</th>\n<th align=\"center\">Native?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code class=\"language-text\">i32</code></td>\n<td align=\"center\"><code class=\"language-text\">(i32)</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">f32</code></td>\n<td align=\"center\"><code class=\"language-text\">(f32)</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">i64</code></td>\n<td align=\"center\"><code class=\"language-text\">(i64)</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">f64</code></td>\n<td align=\"center\"><code class=\"language-text\">(f64)</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n</tbody>\n</table>\n<p>Walt supports all of the native WebAssembly types. They can be used in expressions, assigned to variables, returned from functions, imported and exported from modules.</p>\n<h2>Function Types</h2>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>s-expression</th>\n<th>Native?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">type Fun1Type = () =&gt; void</code></td>\n<td><code class=\"language-text\">(type (func))</code></td>\n<td>‚úÖ</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">type Fun2Type = (i32) =&gt; void</code></td>\n<td><code class=\"language-text\">(type (func (param i32)))</code></td>\n<td>‚úÖ</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">type Fun3Type = (i32) =&gt; i32</code></td>\n<td><code class=\"language-text\">(type (func (param i32) (result i32)))</code></td>\n<td>‚úÖ</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">type Closure = Lambda&lt;Func3Type&gt;</code></td>\n<td><code class=\"language-text\">(type (func (param i32 i32) (result i32)))</code></td>\n<td>‚ùå</td>\n</tr>\n</tbody>\n</table>\n<p>Walt supports all native WebAssembly type definitions. Type definitions are necessary for module imports and function pointers. Lambdas are an exception as they are not natively supported by WebAssembly, a lambda type is encoded with an additional <code class=\"language-text\">i32</code> which is used as a memory offset for the closure environment.</p>\n<h2>Special Types</h2>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>s-expression</th>\n<th>Native?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">const mem: Memory = { initial: 0, max: 1 }</code></td>\n<td><code class=\"language-text\">(memory 0 1)</code></td>\n<td>‚úÖ</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">const table: Table = { initial: 1, max: 1, element: anyfunc }</code></td>\n<td><code class=\"language-text\">(table 1 1 anyfunc)</code></td>\n<td>‚úÖ</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">Memory</code> and <code class=\"language-text\">Table</code> types are used only to define the corresponding module header. Both can be used to import a table or memory from the environment, however.</p>\n<h2>Array Types</h2>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Syntax</th>\n<th align=\"center\">s-expression</th>\n<th align=\"center\">Native?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code class=\"language-text\">i32[]</code></td>\n<td align=\"center\"><code class=\"language-text\">(i32)</code></td>\n<td align=\"center\">‚ùå</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">f32[]</code></td>\n<td align=\"center\"><code class=\"language-text\">(f32)</code></td>\n<td align=\"center\">‚ùå</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">i64[]</code></td>\n<td align=\"center\"><code class=\"language-text\">(i64)</code></td>\n<td align=\"center\">‚ùå</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">f64[]</code></td>\n<td align=\"center\"><code class=\"language-text\">(f64)</code></td>\n<td align=\"center\">‚ùå</td>\n</tr>\n</tbody>\n</table>\n<p>Array types are used to declare variables which will be used as arrays in the source code. They are only necessary as compiler hints and compile down to basic types in the final binary.</p>\n<h2>Struct Types</h2>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>s-expression</th>\n<th>Native?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">type abcs = { a: i32, b: i32, c: i32 }</code></td>\n<td>---</td>\n<td>‚ùå</td>\n</tr>\n</tbody>\n</table>\n<p>Struct types are used as compiler hints to Walt when assigning to and accessing structured data in memory.</p>\n<h2>Declarations</h2>\n<p>All declarations are created via <code class=\"language-text\">const</code> and <code class=\"language-text\">let</code>. The global or local scope is determined by where the variables are defined. Each declaration uses the <em>type-cast</em> operator <code class=\"language-text\">:</code>. ü¶Ñ  <em>In the future, type inference will be available for left-hand-side of the declaration and the type operator will be optional.</em> </p>\n<h3>With Globals</h3>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>s-expression</th>\n<th>Native?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">const x: i32 = 0</code></td>\n<td><code class=\"language-text\">(global i32 (i32.const 0))</code></td>\n<td>‚úÖ</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">let x: i32 = 0</code></td>\n<td><code class=\"language-text\">(global (mut i32) (i32.const 0))</code></td>\n<td>‚úÖ</td>\n</tr>\n</tbody>\n</table>\n<h3>With Function Locals</h3>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>s-expression</th>\n<th>Native?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">const x: i32 = 0</code></td>\n<td><code class=\"language-text\">(local i32) (set_local 0 (i32.const 0))</code></td>\n<td>‚ùå</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">let x: i32 = 0</code></td>\n<td><code class=\"language-text\">(local i32) (set_local 0 (i32.const 0))</code></td>\n<td>‚úÖ</td>\n</tr>\n</tbody>\n</table>\n<p>Notice that both <code class=\"language-text\">const</code> and <code class=\"language-text\">let</code> compile into the same WebAssembly expression(s). This is because WebAssembly <em>has no native immutable locals</em>. Using <code class=\"language-text\">const</code> is a compiler hint, which will result in a compile-error if you attempt to re-assign to a <code class=\"language-text\">const</code> variable.</p>\n<h3>With Function, Object and Lambda types</h3>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>s-expression</th>\n<th>Native?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">let ptr: FnType = 0</code></td>\n<td><code class=\"language-text\">(local i32) (set_local 0 (i32.const 0))</code></td>\n<td>‚ùå</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">let obj: StructType = 0</code></td>\n<td><code class=\"language-text\">(local i32) (set_local 0 (i32.const 0))</code></td>\n<td>‚ùå</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">let lambda: LambdaType = 0</code></td>\n<td><code class=\"language-text\">(local i64) (set_local 0 (i64.const 0))</code></td>\n<td>‚ùå</td>\n</tr>\n</tbody>\n</table>\n<p>Function pointers are encoded as a 32-bit table address. Struct variables are encoded as a 32-bit memory offset. Lambdas are a special case of a <a href=\"https://www.quora.com/What-is-a-fat-pointer\">fat pointer</a> containing both a memory offset(LSW) and a table index for the lambda used(MSW), encoded as a 64-bit integer.</p>\n<h2>Math</h2>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Syntax</th>\n<th align=\"center\">s-expression</th>\n<th align=\"center\">Native?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code class=\"language-text\">+</code></td>\n<td align=\"center\"><code class=\"language-text\">type.add</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">-</code></td>\n<td align=\"center\"><code class=\"language-text\">type.sub</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">/</code></td>\n<td align=\"center\"><code class=\"language-text\">type.div_s</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">*</code></td>\n<td align=\"center\"><code class=\"language-text\">type.mul</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">%</code></td>\n<td align=\"center\"><code class=\"language-text\">type.rem_s</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">&amp;</code></td>\n<td align=\"center\"><code class=\"language-text\">type.and</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">\\|</code></td>\n<td align=\"center\"><code class=\"language-text\">type.or</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">^</code></td>\n<td align=\"center\"><code class=\"language-text\">type.xor</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">&lt;&lt;</code></td>\n<td align=\"center\"><code class=\"language-text\">type.shl</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">&gt;&gt;</code></td>\n<td align=\"center\"><code class=\"language-text\">type.shr_s</code></td>\n<td align=\"center\">‚úÖ</td>\n</tr>\n</tbody>\n</table>\n<p>ü¶Ñ <em>In the future versions of Walt, all of the math operators will be exposed as function members of a native type. For example `i32.shr</em>u(x, y)`.</p>\n<h2>Type-casts and Promotions</h2>\n<p>All operations in WebAssembly must adhere to the strict type of the operator. This means that mixing types requires every mismatched operand to be typecast as the type of the operation. This can get very tedious and fast as different type conversions require different typecasts. Walt makes this a bit easier by performing <a href=\"https://en.wikipedia.org/wiki/Type_conversion\">type promotion</a> in binary expressions behind the scenes. All types are promoted in an expression to the type with the highest expression <em>weight</em>.</p>\n<h3>Type Weights</h3>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Type</th>\n<th align=\"center\">Weight</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code class=\"language-text\">f64</code></td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">f32</code></td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">i64</code></td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\"><code class=\"language-text\">i32</code></td>\n<td align=\"center\">1</td>\n</tr>\n</tbody>\n</table>\n<h3>Manual Type-casts</h3>\n<p>TODO; <code class=\"language-text\">:</code> operator and output WebAssembly</p>\n<h3>Statements and Expressions</h3>\n<p>Walt splits its syntax into statements and expressions (like JavaScript).</p>\n<h3>Comments</h3>\n<p>Walt supports JavaScript comments, inline comments <code class=\"language-text\">//</code> and multi-line comment blocks <code class=\"language-text\">/* */</code>.</p>\n<h3>Functions</h3>\n<p>Everything in Walt as in WebAssembly must have a Type. Functions are no exception to the rule. When a function is declared it's type is hoisted by the compiler behind the scenes. A function type is a list of parameters and a result type.</p>\n<p>:unicorn: Currently a custom function type syntax is not implemented, but is required in order to use custom-function imports.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> log<span class=\"token punctuation\">:</span> Log <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'console'</span><span class=\"token punctuation\">;</span>\ntype <span class=\"token function-variable function\">Log</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>i32<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span></code></pre></div>\n<p>:unicorn: <strong>Arrow Functions</strong>. <em>Might be implemented.</em></p>\n<h3>Function imports and pointers</h3>\n<p>It is possible to import custom functions and use wasm functions as callbacks.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> log<span class=\"token punctuation\">:</span> Log <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'env'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> setTimeout<span class=\"token punctuation\">:</span> Later <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'env'</span><span class=\"token punctuation\">;</span>\n\ntype <span class=\"token function-variable function\">Log</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>i32<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\ntype <span class=\"token function-variable function\">Later</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Function<span class=\"token punctuation\">,</span> i32<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">echo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">echoLater</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">:</span> i32<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>echo<span class=\"token punctuation\">,</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>Compiling the above example will require a <code class=\"language-text\">WebAssembly.Table</code> import to be provided in the imports object.</li>\n</ul>\n<p>Keep in mind that the <code class=\"language-text\">Function</code> parameter is encoded into an <code class=\"language-text\">i32</code> table index. This means that the <code class=\"language-text\">setTimeout</code> function\nmust be a wrapper which can get the <em>real</em> wasm function pointer from a table object. Like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  setTimeout<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>tableIndex<span class=\"token punctuation\">,</span> timeout<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> pointer <span class=\"token operator\">=</span> tableInstance<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>tableIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>pointer<span class=\"token punctuation\">,</span> timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Arrays, Object, Memory</h3>\n<p>Simple rules about objects and arrays.</p>\n<ul>\n<li>Both arrays and objects are stored in the heap, NOT on the stack</li>\n<li>Walt has no built-in memory functions like <code class=\"language-text\">new</code> or <code class=\"language-text\">delete</code></li>\n<li>There is no <em>special</em> syntax for pointers, regular 32-bit address integers are used</li>\n<li>Every object and array must be initialized with an address.</li>\n<li>Every custom object must have a corresponding type definition</li>\n<li>Object Type definitions are <em>not</em> present in any way in the final binary output. They are used as compiler hints.</li>\n<li><code class=\"language-text\">type</code> keyword is used to create a new user-type. Types can be object or function types.</li>\n<li>Dynamic keys are not allowed/will not work.</li>\n<li><em>Except</em> for arrays, which currently have no out-of-bounds checks.</li>\n<li>Arrays of custom types are <em>not yet</em> supported</li>\n<li>Walt <strong>does not implicitly import Memory</strong>, memory must be manually imported OR declared before any memory operations can be used.</li>\n</ul>\n<p>Mainly these makes it easier to write a compiler for Walt. Interop between JavaScript and Walt becomes\nsimpler as well and the \"syntax sugar\" is kept to a minimum on top of the existing WebAssembly functionality.</p>\n<p>Before using arrays or objects memory must be declared</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> memory<span class=\"token punctuation\">:</span> Memory <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'initial'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Array example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// Unlike objects arrays do not require custom types and can be declared in-place</span>\n<span class=\"token keyword\">const</span> intArr<span class=\"token punctuation\">:</span> i32<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// There are no static array sizes and they can be read/written to at any index</span>\nintArr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Keep in mind that out-of-bounds memory access will result in a runtime error</span>\nintArr<span class=\"token punctuation\">[</span><span class=\"token number\">255</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Object example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// Object types are js-like objects with key value pairs of object properties</span>\n<span class=\"token comment\">// and corresponding built-in basic types (i32, f32, i64, f64)</span>\ntype FooType <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">:</span> i32 <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Objects must be initialized with an address</span>\n<span class=\"token comment\">// NOTE: Walt runtime will _not_ perform any safety checks on this address</span>\n<span class=\"token keyword\">const</span> foo<span class=\"token punctuation\">:</span> FooType <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Property lookups are performed as string subscripts</span>\nfoo<span class=\"token punctuation\">[</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Because objects are compiled down to a single integer address, they can be freely</span>\n<span class=\"token comment\">// passed around to other functions or put into other objects</span>\n<span class=\"token function\">someOtherFunction</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// (i32) => void</span></code></pre></div>\n<h3>Module</h3>\n<p>Every Walt file is compiled into a stand-alone module. <code class=\"language-text\">module</code> is a future-reserved keyword.</p>","frontmatter":{"path":"/syntax","title":"Syntax"}}},"pageContext":{}}