{"data":{"markdownRemark":{"html":"<h2>Compiler Architecture</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                           Source Code\n                                +\n                                |\n                          +-----v------+\n                    +-----+  Tokenizer |\n                    |     +------------+\n                    |\n      Token Stream  |\n                    |     +------------+\n                    +-----&gt;   Parser   +------+\n                          +------------+      |\n                                              | Abstract Syntax Tree\n                                              |     (no types)\n                          +------------+      |\n                     +----+  Semantics &lt;------+\n                     |    +------------+\n       AST with type |\n        Information  |\n                     |    +------------+\n                     +----&gt;  Validator +------+\n                          +------------+      |\n                                              |   Validation\n                                              | (types, syntax)\n                          +-------------+     |\n                     +----+  Generator  &lt;-----+\n                     |    +-------------+\n   Intermediate Code |\n     Representation  |\n                     |    +-------------+\n                     +----&gt;   Emiter    |\n                          +-------------+\n                                 |\n                                 v\n                              Binary</code></pre></div>\n<p>Walt uses a traditional compiler architecture, the pipeline is seen above. Each step in the pipeline is a pure function, transforming the input into a new object representing the program. The validator is a minor exception as it performs no transforms on the AST. The parser is a top-down <a href=\"https://en.wikipedia.org/wiki/LL_parser\">LL(1) parser</a>.</p>\n<h2>Notes</h2>\n<ul>\n<li>WebAssembly spec <a href=\"https://github.com/WebAssembly/wabt\">https://github.com/WebAssembly/wabt</a></li>\n<li>WebAssembly Text format semantics. <a href=\"https://github.com/WebAssembly/design/blob/master/Semantics.md\">https://github.com/WebAssembly/design/blob/master/Semantics.md</a></li>\n<li>WebAssembly semantics test suite <a href=\"https://github.com/WebAssembly/spec/tree/master/test/core\">https://github.com/WebAssembly/spec/tree/master/test/core</a></li>\n<li>WebAssembly Binary Toolkit <a href=\"https://github.com/WebAssembly/wabt\">https://github.com/WebAssembly/wabt</a>.</li>\n<li>S-syntax <a href=\"https://github.com/WebAssembly/spec/tree/master/interpreter#s-expression-syntax\">https://github.com/WebAssembly/spec/tree/master/interpreter#s-expression-syntax</a></li>\n<li>WAS Syntax experiment from Mozilla <a href=\"https://github.com/mbebenita/was\">https://github.com/mbebenita/was</a></li>\n</ul>\n<h2>Reference Grammar</h2>\n<p>Not an exhaustive grammar but helps to understand how the compiler works. Was done as an exercise to get the parser off the ground. <strong>Pretty out of date by now.</strong></p>\n<p><em>stmt</em> -> <code class=\"language-text\">let</code> <strong>id</strong> <code class=\"language-text\">;</code></p>\n<p><em>stmt</em> -> <code class=\"language-text\">let</code> <strong>id</strong> <code class=\"language-text\">=</code> <em>expr</em> <code class=\"language-text\">;</code></p>\n<p><em>stmt</em> -> <code class=\"language-text\">const</code> <strong>id</strong> <code class=\"language-text\">=</code> <em>expr</em> <code class=\"language-text\">;</code></p>\n<p><em>stmt</em> -> <code class=\"language-text\">export</code> <em>stmt</em> <code class=\"language-text\">;</code></p>\n<p><em>stmt</em> -> <code class=\"language-text\">import</code> <code class=\"language-text\">{</code> <strong>id</strong> <code class=\"language-text\">:</code> <em>typedef</em> <code class=\"language-text\">}</code> <code class=\"language-text\">from</code> <em>string</em> <code class=\"language-text\">;</code></p>\n<p><em>stmt</em> -> <code class=\"language-text\">if</code> <code class=\"language-text\">(</code> <em>expr</em> <code class=\"language-text\">)</code> <em>stmt</em></p>\n<p><em>stmt</em> -> <code class=\"language-text\">if</code> <code class=\"language-text\">(</code> <em>expr</em> <code class=\"language-text\">)</code> <em>stmt</em> <code class=\"language-text\">else</code> <em>stmt</em></p>\n<p><em>stmt</em> -> <code class=\"language-text\">while</code> <code class=\"language-text\">(</code> <em>expr</em> <code class=\"language-text\">)</code> <em>stmt</em></p>\n<p><em>stmt</em> -> <code class=\"language-text\">do</code> <em>stmt</em> <code class=\"language-text\">while</code> <code class=\"language-text\">(</code> <em>expr</em> <code class=\"language-text\">)</code></p>\n<p><em>stmt</em> -> <code class=\"language-text\">function</code> <strong>id</strong> <code class=\"language-text\">(</code> <em>arglist</em> <code class=\"language-text\">)</code> <code class=\"language-text\">:</code> <em>returntype</em> <em>stmt</em></p>\n<p><em>returntype</em> -> <em>type</em> | <code class=\"language-text\">void</code></p>\n<p><em>stmt</em> -> <code class=\"language-text\">{</code> <em>stmts</em> <code class=\"language-text\">}</code></p>\n<p><em>stmts</em> -> <em>stmts</em> <em>stmt</em> | <em>e</em></p>\n<p><em>arglist</em> -> <em>arglist</em> <em>arg</em> | <em>e</em></p>\n<p><em>arg</em> -> <strong>id</strong> <code class=\"language-text\">:</code> <em>type</em> | <em>arg</em> , <em>arg</em></p>\n<p><em>type</em> -> <code class=\"language-text\">i32</code> | <code class=\"language-text\">i64</code> | <code class=\"language-text\">f32</code> | <code class=\"language-text\">f64</code></p>\n<p><em>typedef</em> -> <em>type</em> | <code class=\"language-text\">anyfunc</code></p>\n<p><em>expr</em> -> <em>expr</em> <code class=\"language-text\">+</code> <em>term</em></p>\n<p><em>expr</em> -> <em>expr</em> <code class=\"language-text\">-</code> <em>term</em></p>\n<p><em>expr</em> -> <em>term</em></p>\n<p><em>expr</em> -> <strong>id</strong> <code class=\"language-text\">(</code> <em>paramlist</em> <code class=\"language-text\">)</code></p>\n<p><em>paramlist</em> -> <em>e</em> | <em>paramlist</em></p>\n<p><em>paramlist</em> -> <em>param</em> , <em>param</em> | <em>param</em></p>\n<p><em>pram</em> -> <strong>id</strong> | <em>string</em> | <em>expr</em></p>\n<p><em>term</em> -> <em>term</em> <code class=\"language-text\">*</code> <em>factor</em></p>\n<p><em>term</em> -> <em>term</em> <code class=\"language-text\">/</code> <em>factor</em></p>\n<p><em>term</em> -> <em>factor</em></p>\n<p><em>factor</em> -> <code class=\"language-text\">(</code><em>expr</em><code class=\"language-text\">)</code></p>\n<p><em>factor</em> -> <em>number</em></p>\n<p><em>number</em> -> <em>number</em> <em>integer</em></p>\n<p><em>number</em> -> <em>number</em> <code class=\"language-text\">.</code> <em>number</em> | <em>number</em> | <em>e</em></p>\n<p><em>integer</em> -> <code class=\"language-text\">0</code>|<code class=\"language-text\">1</code>|<code class=\"language-text\">2</code>|<code class=\"language-text\">3</code>|<code class=\"language-text\">4</code>|<code class=\"language-text\">5</code>|<code class=\"language-text\">6</code>|<code class=\"language-text\">7</code>|<code class=\"language-text\">8</code>|<code class=\"language-text\">9</code></p>\n<p><em>string</em> -> <code class=\"language-text\">&#39;</code> <em>chars</em> <code class=\"language-text\">&#39;</code></p>\n<p><em>chars</em> -> <em>chars</em> <em>char</em> | <em>char</em> | <em>e</em></p>\n<p><em>char</em> -> <strong>UTF-8</strong></p>","frontmatter":{"path":"/compiler","title":"Compiler Internals"}}},"pageContext":{}}